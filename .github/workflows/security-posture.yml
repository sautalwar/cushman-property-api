# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SECURITY POSTURE DASHBOARD
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# What this file does (plain English):
#
# This workflow is the "always-on security camera" for your API.
# It runs automatically every 15 minutes and on every code push.
# It does four things in sequence:
#
#   1. READS   â€” Asks GitHub Advanced Security API: "what have you already found?"
#   2. PROBES  â€” Makes real HTTP requests to the live API to find runtime issues
#   3. REPORTS â€” Formats all findings as SARIF and uploads to GitHub Security tab
#   4. ACTS    â€” Creates GitHub Issues for new findings so a human can approve fixes
#
# The result is a single "security posture" report visible in GitHub Actions
# AND in the Security tab â€” one source of truth for the entire engineering team.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

name: "ğŸ” Security Posture Dashboard"

# â”€â”€â”€ SECTION A: WHEN DOES THIS RUN? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# This workflow runs in three situations:
#
#   schedule  â†’ Automatically every 15 minutes, 24/7, even with no code changes.
#               This is the "always watching" behaviour. No human needs to trigger it.
#
#   push      â†’ Every time a developer pushes code to main. Catches regressions
#               immediately â€” if a new commit introduces a vulnerability, this
#               workflow finds it within seconds of the push.
#
#   pull_request â†’ Every time a PR is opened. Blocks the merge if new vulns are found.
#
#   workflow_dispatch â†’ Manual trigger from the GitHub UI with options. Useful for
#                       running a full audit on demand during an incident review.
#
on:
  schedule:
    - cron: '*/15 * * * *'      # Every 15 minutes â€” the heartbeat of your security posture
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment to probe'
        type: choice
        default: 'staging'
        options: [staging, production, local]
      fail_on_high:
        description: 'Fail workflow if HIGH or CRITICAL vulnerabilities found?'
        type: boolean
        default: true

# â”€â”€â”€ SECTION B: PERMISSIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# GitHub Actions workflows run with a scoped token (GITHUB_TOKEN).
# By default it can only read. We need to explicitly grant the extra
# permissions this workflow needs:
#
#   security-events: write  â†’ Allows uploading SARIF results to the Security tab
#   issues: write           â†’ Allows creating GitHub Issues for new findings
#   contents: read          â†’ Allows reading the repo (checking out code)
#
# IMPORTANT: These are the MINIMUM permissions needed. The principle of least
# privilege â€” we only ask for what we actually use.
#
permissions:
  security-events: write
  issues: write
  contents: read

env:
  GITHUB_REPO: ${{ github.repository }}     # e.g. sautalwar/cushman-property-api
  API_URL:     ${{ vars.API_URL || 'http://localhost:3001' }}

jobs:
  security-posture:
    name: "Security Posture Assessment"
    runs-on: ubuntu-latest

    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 1: CHECKOUT
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Downloads the code from the repository into the runner.
      # Why needed:   The SARIF generation step (Step 4) needs to reference
      #               actual file paths in the source code so GitHub can link
      #               findings to the correct line in the editor.
      - name: "ğŸ“¥ Checkout repository"
        uses: actions/checkout@v4

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 2: READ GHAS CODE SCANNING ALERTS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Calls the GitHub API to get every open code-scanning alert.
      #               Code scanning alerts are created by CodeQL â€” GitHub's
      #               semantic static analyser that reads your source code.
      #
      # Why this matters: Before we run our own probes, we want to know what
      #               GitHub already knows. This prevents duplicate issues and
      #               lets us build a COMBINED picture: static findings + runtime
      #               findings in one report.
      #
      # The API call: GET /repos/{owner}/{repo}/code-scanning/alerts
      #               Returns a JSON array of all open alerts with:
      #               - rule.id          â†’ which security rule triggered
      #               - rule.severity    â†’ critical / high / medium / low
      #               - most_recent_instance.location â†’ file + line number
      #               - html_url         â†’ direct link to the alert in GitHub
      #
      - name: "ğŸ“¡ Step 1 â€” Read GHAS Code Scanning Alerts"
        id: code_scanning
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching code scanning alerts from GitHub Advanced Security..."

          ALERTS=$(gh api \
            "/repos/$GITHUB_REPO/code-scanning/alerts?state=open&per_page=100" \
            --jq '[.[] | {
              id: .number,
              rule: .rule.id,
              severity: .rule.severity,
              description: .rule.description,
              file: .most_recent_instance.location.path,
              line: .most_recent_instance.location.start_line,
              url: .html_url
            }]' 2>/dev/null || echo '[]')

          COUNT=$(echo "$ALERTS" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
          echo "code_scan_count=$COUNT" >> $GITHUB_OUTPUT
          echo "$ALERTS" > /tmp/code_scan_alerts.json
          echo "Found $COUNT open code scanning alerts"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 3: READ SECRET SCANNING ALERTS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Asks GitHub if any secrets (API keys, passwords, tokens,
      #               connection strings) were accidentally committed to git.
      #
      # Why this matters: A leaked JWT_SECRET means an attacker can forge tokens.
      #               A leaked DATABASE_URL gives direct database access.
      #               Secret scanning catches these within seconds of a push â€”
      #               faster than any human code review.
      #
      # The API call: GET /repos/{owner}/{repo}/secret-scanning/alerts
      #               Returns: secret_type (e.g. "github_personal_access_token"),
      #               location (file + line), push_protection_bypassed (was the
      #               developer warned and pushed anyway?)
      #
      - name: "ğŸ”‘ Step 2 â€” Read Secret Scanning Alerts"
        id: secret_scanning
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching secret scanning alerts..."

          SECRETS=$(gh api \
            "/repos/$GITHUB_REPO/secret-scanning/alerts?state=open&per_page=50" \
            --jq '[.[] | {
              id: .number,
              type: .secret_type_display_name,
              bypassed: .push_protection_bypassed,
              url: .html_url
            }]' 2>/dev/null || echo '[]')

          COUNT=$(echo "$SECRETS" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
          echo "secret_count=$COUNT" >> $GITHUB_OUTPUT
          echo "$SECRETS" > /tmp/secret_alerts.json
          echo "Found $COUNT open secret scanning alerts"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 4: READ DEPENDABOT ALERTS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Checks every npm package in package.json against the
      #               GitHub Advisory Database â€” a continuously updated database
      #               of known CVEs (Common Vulnerabilities and Exposures).
      #
      # Why this matters: 80% of modern application code is open-source
      #               dependencies. A vulnerability in an npm package you use
      #               is just as dangerous as one in your own code.
      #               Example: CVE-2021-44228 (Log4Shell) â€” if you used log4j,
      #               Dependabot would have flagged it the day it was published.
      #
      # The API call: GET /repos/{owner}/{repo}/dependabot/alerts
      #               Returns: CVE ID, severity, package name, vulnerable version,
      #               patched version, and a direct advisory URL.
      #
      - name: "ğŸ“¦ Step 3 â€” Read Dependabot Vulnerability Alerts"
        id: dependabot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching Dependabot alerts..."

          DEPS=$(gh api \
            "/repos/$GITHUB_REPO/dependabot/alerts?state=open&per_page=50" \
            --jq '[.[] | {
              id: .number,
              package: .dependency.package.name,
              severity: .security_vulnerability.severity,
              cve: .security_advisory.cve_id,
              summary: .security_advisory.summary,
              patched_version: .security_vulnerability.first_patched_version.identifier,
              url: .html_url
            }]' 2>/dev/null || echo '[]')

          COUNT=$(echo "$DEPS" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
          echo "dep_count=$COUNT" >> $GITHUB_OUTPUT
          echo "$DEPS" > /tmp/dep_alerts.json
          echo "Found $COUNT open Dependabot alerts"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 5: LIVE RUNTIME API PROBES
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: This is the step that makes this workflow unique compared
      #               to pure static analysis tools. It makes ACTUAL HTTP requests
      #               to the running API and tests whether each vulnerability
      #               exists at runtime â€” not just in the code.
      #
      # Why this matters: Static analysis (CodeQL) reads code but cannot know
      #               about runtime configuration â€” environment variables,
      #               middleware order, framework behaviour, or infrastructure
      #               settings. Runtime probes catch what static analysis misses.
      #
      # What each probe does:
      #   BOLA probe      â†’ Logs in as Bob, tries to read Alice's job. If HTTP 200
      #                     â†’ VULN-1 confirmed: no ownership check at runtime.
      #   Auth probe      â†’ Sends a token with exp set 1 hour ago. If HTTP 200
      #                     â†’ VULN-2 confirmed: ignoreExpiration is still true.
      #   Rate limit      â†’ Sends 25 requests rapidly. If no 429 returned
      #                     â†’ VULN-6 confirmed: no per-user throttle.
      #   SQL injection   â†’ Sends q=' OR 1=1 -- to /search. If row count spikes
      #                     â†’ VULN-8 confirmed: string concatenation in SQL.
      #
      - name: "ğŸ”¬ Step 4 â€” Live Runtime API Probes"
        id: probes
        run: |
          API="${API_URL:-http://localhost:3001}"
          echo '{"findings":[]}' > /tmp/runtime_findings.json

          python3 .github/scripts/sp_probe.py

          COUNT=$(python3 -c "import json; d=json.load(open('/tmp/runtime_findings.json')); print(len(d['findings']))")
          echo "runtime_count=$COUNT" >> $GITHUB_OUTPUT

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 6: GENERATE SARIF FILE
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Converts our runtime probe findings into SARIF format.
      #
      # What is SARIF? Static Analysis Results Interchange Format â€” an open
      #               standard (JSON schema) for representing security tool output.
      #               GitHub's Security tab understands SARIF natively, so by
      #               converting our custom probe results to SARIF, they appear
      #               in the SAME place as CodeQL findings â€” one unified view.
      #
      # Why this is powerful: Without SARIF, our probe results only exist in
      #               the Actions log â€” engineers have to dig through job logs.
      #               With SARIF, findings appear in:
      #                 â†’ Security > Code scanning (with file + line links)
      #                 â†’ Pull request checks (inline annotation on the diff)
      #                 â†’ Security Overview (org-wide aggregation)
      #               This turns our custom scripts into a first-class GHAS tool.
      #
      - name: "ğŸ“„ Step 5 â€” Generate SARIF from Runtime Findings"
        run: python3 .github/scripts/sp_sarif.py

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 7: UPLOAD SARIF TO GITHUB SECURITY TAB
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Sends the SARIF file to GitHub using the official
      #               CodeQL upload action. GitHub then processes it and makes
      #               each finding visible in the Security > Code Scanning tab,
      #               with direct links to the affected file and line number.
      #
      # Why use the action instead of the API directly?
      #               The action handles: gzip compression, base64 encoding,
      #               chunked upload for large files, retry on failure, and
      #               correctly sets the commit SHA so findings are pinned to
      #               the right version of the code.
      #
      - name: "â¬†ï¸  Step 6 â€” Upload SARIF to GitHub Security"
        uses: github/codeql-action/upload-sarif@v3
        if: always()   # Upload even if probes found issues (we WANT them in Security tab)
        with:
          sarif_file: /tmp/results.sarif
          category: runtime-api-probe   # Groups these findings separately from CodeQL

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 8: CREATE GITHUB ISSUES FOR NEW FINDINGS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: For every runtime finding, checks if a GitHub Issue with
      #               that vulnerability ID is already open. If not, creates one.
      #               The issue includes: evidence, AI recommendation, and
      #               two label options (apply-fix / risk-accepted) so a human
      #               can decide whether to apply the Copilot-generated fix.
      #
      # Why check before creating? Deduplication. If the vulnerability exists
      #               in every run for 2 weeks, we don't want 1,344 duplicate issues.
      #               We create ONE issue and it stays open until the fix is merged.
      #
      - name: "ğŸš¨ Step 7 â€” Create GitHub Issues for New Findings"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python3 .github/scripts/sp_issues.py

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 9: WRITE SECURITY POSTURE DASHBOARD TO STEP SUMMARY
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: Generates a rich markdown report and writes it to
      #               GITHUB_STEP_SUMMARY â€” a special GitHub variable that
      #               renders markdown in the Actions run summary page.
      #
      # The report combines ALL four data sources into one view:
      #   - GHAS Code Scanning alert count
      #   - Secret Scanning alert count
      #   - Dependabot CVE count
      #   - Runtime probe findings with severity breakdown
      #   - Overall risk score (weighted by severity)
      #   - Links to open issues for remediation
      #
      - name: "ğŸ“Š Step 8 â€” Write Security Posture Dashboard"
        env:
          CODE_SCAN_COUNT: ${{ steps.code_scanning.outputs.code_scan_count }}
          SECRET_COUNT:    ${{ steps.secret_scanning.outputs.secret_count }}
          DEP_COUNT:       ${{ steps.dependabot.outputs.dep_count }}
          RUNTIME_COUNT:   ${{ steps.probes.outputs.runtime_count }}
          GH_TOKEN:        ${{ secrets.GITHUB_TOKEN }}
        run: python3 .github/scripts/sp_dashboard.py

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 10: FAIL THE WORKFLOW IF CRITICAL/HIGH FINDINGS EXIST
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # What it does: If this workflow is running on a pull_request AND the
      #               fail_on_high input is true (default), fails the check
      #               so the PR cannot be merged until vulnerabilities are resolved.
      #
      # Why fail? This is the "enforcement gate". Without it, security findings
      #               are informational only. By failing the PR check, we make
      #               security non-negotiable â€” a developer cannot ship vulnerable
      #               code without an explicit override from an admin.
      #
      - name: "ğŸš¦ Step 9 â€” Enforce: Fail on Critical or High Findings"
        if: github.event_name == 'pull_request' || inputs.fail_on_high == true
        run: |
          COUNT="${{ steps.probes.outputs.runtime_count }}"
          if [ "$COUNT" -gt "0" ] && [ "${{ inputs.fail_on_high }}" != "false" ]; then
            echo "::error::Security Posture Check FAILED â€” $COUNT runtime vulnerability/vulnerabilities detected."
            echo "::error::Review the Security Posture Dashboard in the Actions summary and apply AI recommendations."
            exit 1
          fi
          echo "âœ… Security posture check passed â€” no blocking findings."
